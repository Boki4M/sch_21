#include <stdio.h>   //библиотека для ввода/вывода
#include <unistd.h>  //библиотека для задержки выполнения (функция usleep)

// Определяем константы для размера игрового поля
#define WIDTH 80   // деректива задающая размер ШИРИНЫ поля - 80 символов
#define HEIGHT 25  // деректива задающая размер ВЫСОТЫ поля - 25 символов

// функция считающая живых соседей для клетки
int count_live_neighbors(char field[HEIGHT][WIDTH], int row, int col);
// Объявление функции update_field, которая обновляет состояние игрового поля
// current - текущее состояние поля (двумерный массив 25x80)
// next - массив для записи следующего состояния поля
void update_field(char current[HEIGHT][WIDTH], char next[HEIGHT][WIDTH]);
// Объявление функции print_field, которая отвечает за отображение игрового поля
// Функция принимает один параметр - двумерный массив field размером HEIGHT x WIDTH
void print_field(char field[HEIGHT][WIDTH]);
// Объявление функции initialize_field, которая инициализирует игровое поле
// Функция принимает один параметр - двумерный массив field размером HEIGHT x WIDTH
// Этот массив представляет собой игровое поле размером 25 строк на 80 столбцов
void initialize_field(char field[HEIGHT][WIDTH]);

// Главная функция программы - точка входа, выполнение начинается отсюда
int main() {
    // СОЗДАНИЕ ИГРОВЫХ ПОЛЕЙ:
    // Объявляем два двумерных массива (матрицы) типа char размером HEIGHT x WIDTH
    // current - представляет текущее состояние игрового поля
    // next - будет использоваться для расчета следующего состояния поля
    char current[HEIGHT][WIDTH];
    char next[HEIGHT][WIDTH];

    // ИНИЦИАЛИЗАЦИЯ ПОЛЕЙ:
    // Вызываем функцию initialize_field для заполнения обоих массивов начальными значениями
    // Сначала все клетки будут установлены в ' ' (мертвые), затем некоторые станут '0' (живые)
    initialize_field(current);
    initialize_field(next);

    // ОСНОВНОЙ ИГРОВОЙ ЦИКЛ:
    // Бесконечный цикл (while(1)) - игра будет работать пока пользователь не прервет выполнени
    while (1) {
        // ОТОБРАЖЕНИЕ ТЕКУЩЕГО СОСТОЯНИЯ:
        // Вызываем функцию print_field для отрисовки текущего состояния поля на экране
        print_field(current);

        // РАСЧЕТ СЛЕДУЮЩЕГО СОСТОЯНИЯ:
        // Вызываем функцию update_field, которая применяет правила игры "Жизнь"
        // На основе current рассчитывает next (следующее поколение клеток)
        update_field(current, next);

        // ОБНОВЛЕНИЕ ТЕКУЩЕГО СОСТОЯНИЯ:
        // Копируем рассчитанное состояние next в current
        // Два вложенных цикла проходят через каждую клетку поля
        for (int i = 0; i < HEIGHT; i++) {     // Для каждой строки (0-24)
            for (int j = 0; j < WIDTH; j++) {  // Для каждого столбца (0-79)
                current[i][j] = next[i][j];    // Копируем значение из next в current
            }
        }

        // ПАУЗА ДЛЯ АНИМАЦИИ:
        // Приостанавливаем выполнение программы на 300000 микросекунд (0.3 секунды)
        // Это создает задержку между кадрами, чтобы анимация была плавной и видимой
        usleep(300000);
    }

    // ВОЗВРАТ ИЗ ПРОГРАММЫ:
    // Теоретически, функция должна вернуть 0 (успешное завершение)
    // Но из-за бесконечного цикла эта строка никогда не будет достигнута
    return 0;
}

// функция считающая живых соседей для клетки
int count_live_neighbors(char field[HEIGHT][WIDTH], int row, int col) {
    int count = 0;  // счетчик живых клеток

    // перебираем всех соседей
    // Вместе эти циклы перебирают все 8 соседних клеток + текущую
    for (int i = -1; i <= 1; i++) {          // Проход по всем соседям по вертикали
        for (int j = -1; j <= 1; j++) {      // Проход по всем соседям по горизонтали
            if (i == 0 && j == 0) continue;  // Пропускаем саму клетку

            // Вычисление координаты соседий клетки
            int r = row + i;  // номер строки соседа
            int c = col + j;  // номер стотлбца соседа

            // Проверяем, что сосед находится в пределах игрового поля
            if (r >= 0 && r < HEIGHT && c >= 0 && c < WIDTH) {
                // Если сосед живой (содержит символ '0'), увеличиваем счетчик
                if (field[r][c] == '0') {
                    count++;
                }
            }
        }
    }
    return count;  // возвращаем количество соседей
}

// Объявление функции update_field, которая обновляет состояние игрового поля
// current - текущее состояние поля (двумерный массив 25x80)
// next - массив для записи следующего состояния поля
void update_field(char current[HEIGHT][WIDTH], char next[HEIGHT][WIDTH]) {
    // Внешний цикл: перебираем все строки игрового поля (от 0 до HEIGHT-1)
    for (int i = 0; i < HEIGHT; i++) {
        // Внутренний цикл: перебираем все столбцы в текущей строке (от 0 до WIDTH-1)
        for (int j = 0; j < WIDTH; j++) {
            // Подсчитываем количество живых соседей вокруг текущей клетки [i][j]
            // Функция count_live_neighbors проверяет все 8 соседних клеток
            int live_neighbors =
                count_live_neighbors(current, i, j);  // в переменную записываем количество живых клеток

            // Проверяем, является ли текущая клетка живой (содержит символ '0')
            if (current[i][j] == '0') {
                // ПРАВИЛА ДЛЯ ЖИВЫХ КЛЕТОК:

                // Правило 1: Одиночество - если живых соседей меньше 2, клетка умирает
                // Правило 2: Перенаселение - если живых соседей больше 3, клетка умирает
                if (live_neighbors < 2 || live_neighbors > 3) {
                    next[i][j] = ' ';  // Клетка умирает (записываем пробел)
                } else {
                    next[i][j] = '0';  // Клетка выживает (остается живой)
                }
            } else {
                // ЕСЛИ КЛЕТКА МЕРТВАЯ:

                // Правило 4: Размножение - если ровно 3 живых соседа, клетка оживает
                if (live_neighbors == 3) {
                    next[i][j] = '0';  // Клетка рождается (становится живой)
                } else {
                    next[i][j] = ' ';  // Клетка остается мертвой
                }
            }
        }
    }
}

// Объявление функции print_field, которая отвечает за отображение игрового поля
// Функция принимает один параметр - двумерный массив field размером HEIGHT x WIDTH
void print_field(char field[HEIGHT][WIDTH]) {
    // Управляющие последовательности ANSI для очистки экрана терминала:
    // \033 - это Escape-символ (ASCII 27), который начинает управляющую последовательность
    // [H - перемещает курсор в верхний левый угол экрана (позиция 1,1)
    // [J - очищает экран от позиции курсора до конца экрана
    // Вместе эта команда очищает весь экран и помещает курсор в начало
    printf("\033[H\033[J");

    // Внешний цикл for: перебираем все строки игрового поля (от 0 до HEIGHT-1)
    // i - переменная-счетчик, представляет текущий номер строки
    for (int i = 0; i < HEIGHT; i++) {
        // Внутренний цикл for: перебираем все столбцы в текущей строке (от 0 до WIDTH-1)
        // j - переменная-счетчик, представляет текущий номер столбца
        for (int j = 0; j < WIDTH; j++) {
            // Выводим символ из текущей клетки поля:
            // field[i][j] - обращение к элементу массива в строке i, столбце j
            // %c - спецификатор формата для вывода одного символа
            printf("%c", field[i][j]);
        }
        // После вывода всех символов в текущей строке переходим на новую строку
        // Это нужно, чтобы следующая строка поля отображалась ниже предыдущей
        printf("\n");
    }
    // Принудительно сбрасываем буфер вывода, чтобы все данные сразу отобразились на экране
    // Обычно printf буферизирует вывод для эффективности, но в реальном времени
    // нам важно видеть результат сразу, без задержек
    fflush(stdout);
}

// Объявление функции initialize_field, которая инициализирует игровое поле
// Функция принимает один параметр - двумерный массив field размером HEIGHT x WIDTH
// Этот массив представляет собой игровое поле размером 25 строк на 80 столбцов
void initialize_field(char field[HEIGHT][WIDTH]) {
    // Внешний цикл for: перебираем все строки игрового поля (от 0 до HEIGHT-1)
    // i - переменная-счетчик, представляет текущий номер строки (от 0 до 24)
    for (int i = 0; i < HEIGHT; i++) {
        // Внутренний цикл for: перебираем все столбцы в текущей строке (от 0 до WIDTH-1)
        // j - переменная-счетчик, представляет текущий номер столбца (от 0 до 79)
        for (int j = 0; j < WIDTH; j++) {
            // Инициализируем текущую клетку поля пробелом
            // Пробел ' ' представляет мертвую клетку в игре "Жизнь"
            // Это базовая настройка - сначала все клетки мертвые
            field[i][j] = ' ';
        }
    }

    // установка начальных живых клеток
    field[5][23] = field[5][24] = field[5][25] = field[5][26] = field[5][27] = field[5][28] = field[5][29] =
        field[5][30] = field[5][31] = field[5][32] = field[5][39] = field[5][40] = field[5][41] = '0';
    field[6][23] = field[6][24] = field[6][25] = field[6][26] = field[6][27] = field[6][28] = field[6][29] =
        field[6][30] = field[6][31] = field[6][32] = field[6][39] = field[6][40] = field[6][41] = '0';
    field[7][23] = field[7][24] = field[7][25] = field[7][26] = field[7][27] = field[7][28] = field[7][29] =
        field[7][30] = field[7][31] = field[7][32] = field[7][39] = field[7][40] = field[7][41] = '0';

    field[8][32] = field[8][33] = field[8][34] = field[8][41] = field[8][42] = field[8][43] = '0';
    field[9][32] = field[9][33] = field[9][34] = field[9][41] = field[9][42] = field[9][43] = '0';
    field[10][32] = field[10][33] = field[10][34] = field[10][41] = field[10][42] = field[10][43] = '0';

    field[11][26] = field[11][27] = field[11][28] = field[11][29] = field[11][30] = field[11][31] =
        field[11][41] = field[11][42] = field[11][43] = '0';
    field[12][26] = field[12][27] = field[12][28] = field[12][29] = field[12][30] = field[12][31] =
        field[12][41] = field[12][42] = field[12][43] = '0';
    field[13][26] = field[13][27] = field[13][28] = field[13][29] = field[13][30] = field[13][31] =
        field[13][41] = field[13][42] = field[13][43] = '0';

    field[14][23] = field[14][24] = field[14][25] = field[14][41] = field[14][42] = field[14][43] = '0';
    field[15][23] = field[15][24] = field[15][25] = field[15][41] = field[15][42] = field[15][43] = '0';
    field[16][23] = field[16][24] = field[16][25] = field[16][41] = field[16][42] = field[16][43] = '0';

    field[17][26] = field[17][27] = field[17][28] = field[17][29] = field[17][30] = field[17][31] =
        field[17][32] = field[17][33] = field[17][34] = field[17][41] = field[17][42] = field[17][43] = '0';
    field[18][26] = field[18][27] = field[18][28] = field[18][29] = field[18][30] = field[18][31] =
        field[18][32] = field[18][33] = field[18][34] = field[18][41] = field[18][42] = field[18][43] = '0';
    field[19][26] = field[19][27] = field[19][28] = field[19][29] = field[19][30] = field[19][31] =
        field[19][32] = field[19][33] = field[19][34] = field[19][41] = field[19][42] = field[19][43] = '0';
}