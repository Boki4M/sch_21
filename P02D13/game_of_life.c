#include <stdio.h>
#include <unistd.h>

#define W 80  // ширина поля
#define H 25  // высота поля

// функция отрисовки поля
void print_field(int field[H][W]);
// функция подсчета живых соседей, возвращает число от 0 до 8 - количество живых соседей
int count_neighbors(int f[H][W], int r, int c);
// Объявление функции step (шаг)
// Она принимает два двумерных массива одинакового размера H x W:
// f - текущее состояние игрового поля (current field)
// next - массив, куда будет записано следующее состояние поля
void step(int f[H][W], int next[H][W]);
// Объявление функции copy_field (копирование поля)
// Функция принимает два параметра:
// - dst (destination) - массив-назначение, КУДА будем копировать
// - src (source) - массив-источник, ОТКУДА будем копировать
// Оба массива имеют одинаковые размеры H (высота/строки) x W (ширина/столбцы)
void copy_field(int dst[H][W], int src[H][W]);

// Главная функция программы - точка входа, с которой начинается выполнение
int main() {
    // СОЗДАНИЕ И ИНИЦИАЛИЗАЦИЯ ИГРОВЫХ ПОЛЕЙ:
    // Создаем два двумерных массива (матрицы) размером H (25 строк) × W (80 столбцов)
    // field - текущее состояние игрового поля
    // next - буфер для расчета следующего состояния
    // {0} - инициализируем ВСЕ элементы массивов нулями (все клетки мертвы)
    int field[H][W] = {0}, next[H][W] = {0};

    // НАСТРОЙКА НАЧАЛЬНОЙ КОНФИГУРАЦИИ (расставляем живые клетки):
    // Это формирует сложную начальную конфигурацию (возможно, какой-то рисунок или надпись)
    // Каждая строка активирует (устанавливает в 1) определенные клетки в поле

    // Активируем клетки в строке 5 с столбца 23 по 32 и с столбца 39 по 41
    // Синтаксис field[5][23] = field[5][24] = ... = 1 означает:
    // "присвоить всем указанным клеткам значение 1"
    field[5][23] = field[5][24] = field[5][25] = field[5][26] = field[5][27] = field[5][28] = field[5][29] =
        field[5][30] = field[5][31] = field[5][32] = field[5][39] = field[5][40] = field[5][41] = 1;
    field[6][23] = field[6][24] = field[6][25] = field[6][26] = field[6][27] = field[6][28] = field[6][29] =
        field[6][30] = field[6][31] = field[6][32] = field[6][39] = field[6][40] = field[6][41] = 1;
    field[7][23] = field[7][24] = field[7][25] = field[7][26] = field[7][27] = field[7][28] = field[7][29] =
        field[7][30] = field[7][31] = field[7][32] = field[7][39] = field[7][40] = field[7][41] = 1;

    field[8][32] = field[8][33] = field[8][34] = field[8][41] = field[8][42] = field[8][43] = 1;
    field[9][32] = field[9][33] = field[9][34] = field[9][41] = field[9][42] = field[9][43] = 1;
    field[10][32] = field[10][33] = field[10][34] = field[10][41] = field[10][42] = field[10][43] = 1;

    field[11][26] = field[11][27] = field[11][28] = field[11][29] = field[11][30] = field[11][31] =
        field[11][41] = field[11][42] = field[11][43] = 1;
    field[12][26] = field[12][27] = field[12][28] = field[12][29] = field[12][30] = field[12][31] =
        field[12][41] = field[12][42] = field[12][43] = 1;
    field[13][26] = field[13][27] = field[13][28] = field[13][29] = field[13][30] = field[13][31] =
        field[13][41] = field[13][42] = field[13][43] = 1;

    field[14][23] = field[14][24] = field[14][25] = field[14][41] = field[14][42] = field[14][43] = 1;
    field[15][23] = field[15][24] = field[15][25] = field[15][41] = field[15][42] = field[15][43] = 1;
    field[16][23] = field[16][24] = field[16][25] = field[16][41] = field[16][42] = field[16][43] = 1;

    field[17][26] = field[17][27] = field[17][28] = field[17][29] = field[17][30] = field[17][31] =
        field[17][32] = field[17][33] = field[17][34] = field[17][41] = field[17][42] = field[17][43] = 1;
    field[18][26] = field[18][27] = field[18][28] = field[18][29] = field[18][30] = field[18][31] =
        field[18][32] = field[18][33] = field[18][34] = field[18][41] = field[18][42] = field[18][43] = 1;
    field[19][26] = field[19][27] = field[19][28] = field[19][29] = field[19][30] = field[19][31] =
        field[19][32] = field[19][33] = field[19][34] = field[19][41] = field[19][42] = field[19][43] = 1;

    // ОСНОВНОЙ ЦИКЛ ИГРЫ (игра работает бесконечно):
    // while (1) - создает бесконечный цикл, который будет выполняться всегда
    // Для выхода из программы нужно принудительно прервать ее выполнение (Ctrl+C)
    while (1) {
        // ОТРИСОВКА ТЕКУЩЕГО СОСТОЯНИЯ:
        // Вызываем функцию print_field, передавая ей текущее состояние поля
        // Функция очистит экран и нарисует все клетки
        print_field(field);

        // ПАУЗА ДЛЯ АНИМАЦИИ:
        // Функция usleep приостанавливает выполнение программы на указанное время
        // 300000 микросекунд = 0.3 секунды (300 мс)
        // Это создает задержку между кадрами анимации
        usleep(300000);

        // ВЫЧИСЛЕНИЕ СЛЕДУЮЩЕГО ПОКОЛЕНИЯ:
        // Вызываем функцию step, которая применяет правила игры "Жизнь"
        // Она читает текущее состояние из field, вычисляет следующее состояние
        // и записывает результат в массив next
        step(field, next);

        // ОБНОВЛЕНИЕ ИГРОВОГО ПОЛЯ:
        // Копируем рассчитанное следующее состояние (next) обратно в field
        // Теперь field содержит состояние нового поколения клеток
        copy_field(field, next);

        // ЦИКЛ ПОВТОРЯЕТСЯ:
        // Программа возвращается к началу цикла while
        // Снова отрисовывает поле, делает паузу, вычисляет следующее состояние и т.д.
    }

    // ВОЗВРАТ ИЗ ФУНКЦИИ:
    // Теоретически, программа должна вернуть 0 операционной системе,
    // что означает успешное завершение работы
    // НО: из-за бесконечного цикла while(1) эта строка никогда не будет достигнута
    return 0;
}

// функция отрисовки поля
void print_field(int field[H][W]) {
    printf("\033[H\033[J");                         // очистка экрана
    for (int r = 0; r < H; r++) {                   // спуск на следующую строку
        for (int c = 0; c < W; c++) {               // проход и отрисовка одной строки
            printf("%c", field[r][c] ? 'o' : ' ');  // если клетка живая, то 'o', если мертвая то ' '
        }
        printf("\n");  // переход на следующую строку
    }
}

// функция подсчета живых соседей, возвращает число от 0 до 8 - количество живых соседей
int count_neighbors(int f[H][W], int r,
                    int c) {  // Объявление функции, которая принимает игровое поле и координаты клетки
    int n = 0;                // счетчик живых соседей
    // перебираем всех соседей
    // Вместе эти циклы перебирают все 8 соседних клеток + текущую
    for (int dr = -1; dr <= 1; dr++) {         // Проход по всем соседям по вертикали
        for (int dc = -1; dc <= 1; dc++) {     // Проход по всем соседям по горизонтали
            if (dr == 0 && dc == 0) continue;  // Пропускаем саму клетку
            int rr = r + dr, cc = c + dc;      // Вычисление координат соседней клетки, rr-строки cc-стотлбца
            if (rr >= 0 && rr < H && cc >= 0 && cc < W) {  // проверка на НЕ выход за границу поля
                n += f[rr]
                      [cc];  // увеличиваем счетчик, если соседняя клетка жива (значение 1==живой, 0==мертвый)
            }
        }
    }
    return n;  // возвращаем общее количество живых соседей
}

// Объявление функции step (шаг)
// Она принимает два двумерных массива одинакового размера H x W:
// f - текущее состояние игрового поля (current field)
// next - массив, куда будет записано следующее состояние поля
void step(int f[H][W], int next[H][W]) {
    // Начинаем внешний цикл для перебора всех СТРОК игрового поля
    // int r = 0 - создаем счетчик строк и устанавливаем его в 0 (первая строка)
    // r < H - условие: пока номер строки меньше высоты поля H (25)
    // r++ - после каждой итерации увеличиваем номер строки на 1
    for (int r = 0; r < H; r++) {
        // Внутренний цикл для перебора всех СТОЛБЦОВ в текущей строке
        // int c = 0 - создаем счетчик столбцов и устанавливаем его в 0 (первый столбец)
        // c < W - условие: пока номер столбца меньше ширины поля W (80)
        // c++ - после каждой итерации увеличиваем номер столбца на 1
        for (int c = 0; c < W; c++) {
            // Сохраняем текущее состояние клетки [r][c] в переменную alive
            // f[r][c] может быть:
            // 1 (true) - клетка жива
            // 0 (false) - клетка мертва
            int alive = f[r][c];

            // Вызываем функцию count_neighbors для подсчета живых соседей
            // вокруг текущей клетки [r][c]
            // Функция возвращает число от 0 до 8 - количество живых соседей
            int n = count_neighbors(f, r, c);

            // ВЫЧИСЛЕНИЕ НОВОГО СОСТОЯНИЯ КЛЕТКИ ПО ПРАВИЛАМ ИГРЫ:
            // Это ключевая строка, реализующая все правила игры "Жизнь"
            next[r][c] = (alive && (n == 2 || n == 3)) || (!alive && n == 3);
            // РАЗБЕРЁМ ЭТУ СТРОКУ ПО ЧАСТЯМ:
            //
            // Логическое И (&&) - обе части должны быть истинны
            // Логическое ИЛИ (||) - достаточно истинности одной части
            //
            // ПЕРВАЯ ЧАСТЬ (для живых клеток):
            // (alive && (n == 2 || n == 3))
            // Это означает: "если клетка жива И у нее 2 ИЛИ 3 соседа"
            // Результат: клетка остается живой (1) в следующем поколении
            //
            // ВТОРАЯ ЧАСТЬ (для мертвых клеток):
            // (!alive && n == 3)
            // Это означает: "если клетка мертва И у нее РОВНО 3 соседа"
            // Результат: клетка оживает (1) в следующем поколении
            //
            // ОБЩИЙ РЕЗУЛЬТАТ:
            // Если выполняется первое ИЛИ второе условие - клетка будет живой (1)
            // Если не выполняется ни одно из условий - клетка будет мертвой (0)
        }
    }
}

// Объявление функции copy_field (копирование поля)
// Функция принимает два параметра:
// - dst (destination) - массив-назначение, КУДА будем копировать
// - src (source) - массив-источник, ОТКУДА будем копировать
// Оба массива имеют одинаковые размеры H (высота/строки) x W (ширина/столбцы)
void copy_field(int dst[H][W], int src[H][W]) {
    // НАЧАЛО ВНЕШНЕГО ЦИКЛА - перебор всех СТРОК массива
    // int r = 0 - создаем счетчик строк и инициализируем его нулем (начинаем с первой строки)
    // r < H - условие продолжения цикла: пока номер строки меньше высоты массива H (25)
    // r++ - после каждой итерации увеличиваем счетчик строк на 1
    for (int r = 0; r < H; r++)

        // НАЧАЛО ВНУТРЕННЕГО ЦИКЛА - перебор всех СТОЛБЦОВ в текущей строке
        // int c = 0 - создаем счетчик столбцов и инициализируем его нулем (начинаем с первого столбца)
        // c < W - условие продолжения цикла: пока номер столбца меньше ширины массива W (80)
        // c++ - после каждой итерации увеличиваем счетчик столбцов на 1
        for (int c = 0; c < W; c++)

            // ТЕЛО ЦИКЛА - непосредственно операция копирования
            // Берем значение из ячейки [r][c] массива-источника (src)
            // и записываем его в ячейку [r][c] массива-назначения (dst)
            dst[r][c] = src[r][c];
    // ПРОСТОЙ АНАЛОГИЯ:
    // Представь, что у тебя есть две одинаковые таблицы 25×80 клеток
    // Ты берешь значение из каждой клетки левой таблицы (src)
    // и записываешь его в соответствующую клетку правой таблицы (dst)
}